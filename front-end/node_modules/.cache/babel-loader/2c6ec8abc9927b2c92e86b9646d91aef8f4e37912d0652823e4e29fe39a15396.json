{"ast":null,"code":"import { invariant } from './errors.mjs';\nimport { clamp } from './clamp.mjs';\nimport { pipe } from './pipe.mjs';\nimport { progress } from './progress.mjs';\nimport { noop } from './noop.mjs';\nimport { mix } from './mix/index.mjs';\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || mix;\n  const numMixers = output.length - 1;\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\nfunction interpolate(input, output, {\n  clamp: isClamp = true,\n  ease,\n  mixer\n} = {}) {\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\r\n   * If we're only provided a single input, we can just make a function\r\n   * that returns the output.\r\n   */\n  if (inputLength === 1) return () => output[0];\n  if (inputLength === 2 && input[0] === input[1]) return () => output[1];\n  // If input runs highest -> lowest, reverse both arrays\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n  const mixers = createMixers(output, ease, mixer);\n  const numMixers = mixers.length;\n  const interpolator = v => {\n    let i = 0;\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\nexport { interpolate };","map":{"version":3,"names":["invariant","clamp","pipe","progress","noop","mix","createMixers","output","ease","customMixer","mixers","mixerFactory","numMixers","length","i","mixer","easingFunction","Array","isArray","push","interpolate","input","isClamp","inputLength","reverse","interpolator","v","progressInRange"],"sources":["C:/Alexander/Software Developement/repos/Web2/Fitness-Tracker/front-end/node_modules/framer-motion/dist/es/utils/interpolate.mjs"],"sourcesContent":["import { invariant } from './errors.mjs';\r\nimport { clamp } from './clamp.mjs';\r\nimport { pipe } from './pipe.mjs';\r\nimport { progress } from './progress.mjs';\r\nimport { noop } from './noop.mjs';\r\nimport { mix } from './mix/index.mjs';\r\n\r\nfunction createMixers(output, ease, customMixer) {\r\n    const mixers = [];\r\n    const mixerFactory = customMixer || mix;\r\n    const numMixers = output.length - 1;\r\n    for (let i = 0; i < numMixers; i++) {\r\n        let mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\r\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\r\n    const inputLength = input.length;\r\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\r\n    /**\r\n     * If we're only provided a single input, we can just make a function\r\n     * that returns the output.\r\n     */\r\n    if (inputLength === 1)\r\n        return () => output[0];\r\n    if (inputLength === 2 && input[0] === input[1])\r\n        return () => output[1];\r\n    // If input runs highest -> lowest, reverse both arrays\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [...input].reverse();\r\n        output = [...output].reverse();\r\n    }\r\n    const mixers = createMixers(output, ease, mixer);\r\n    const numMixers = mixers.length;\r\n    const interpolator = (v) => {\r\n        let i = 0;\r\n        if (numMixers > 1) {\r\n            for (; i < input.length - 2; i++) {\r\n                if (v < input[i + 1])\r\n                    break;\r\n            }\r\n        }\r\n        const progressInRange = progress(input[i], input[i + 1], v);\r\n        return mixers[i](progressInRange);\r\n    };\r\n    return isClamp\r\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\r\n        : interpolator;\r\n}\r\n\r\nexport { interpolate };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}