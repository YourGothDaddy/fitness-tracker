{"ast":null,"code":"import { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { invariant } from '../../utils/errors.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nconst generators = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\nconst percentToProgress = percent => percent / 100;\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\nclass MainThreadAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    /**\r\n     * The time at which the animation was paused.\r\n     */\n    this.holdTime = null;\n    /**\r\n     * The time at which the animation was cancelled.\r\n     */\n    this.cancelTime = null;\n    /**\r\n     * The current time of the animation.\r\n     */\n    this.currentTime = 0;\n    /**\r\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n     */\n    this.playbackSpeed = 1;\n    /**\r\n     * The state of the animation to apply when the animation is resolved. This\r\n     * allows calls to the public API to control the animation before it is resolved,\r\n     * without us having to resolve it first.\r\n     */\n    this.pendingPlayState = \"running\";\n    /**\r\n     * The time at which the animation was started.\r\n     */\n    this.startTime = null;\n    this.state = \"idle\";\n    /**\r\n     * This method is bound to the instance to fix a pattern where\r\n     * animation.stop is returned as a reference from a useEffect.\r\n     */\n    this.stop = () => {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.teardown();\n      const {\n        onStop\n      } = this.options;\n      onStop && onStop();\n    };\n    const {\n      name,\n      motionValue,\n      element,\n      keyframes\n    } = this.options;\n    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n    this.resolver.scheduleResolve();\n  }\n  initPlayback(keyframes$1) {\n    const {\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType,\n      velocity = 0\n    } = this.options;\n    const generatorFactory = generators[type] || keyframes;\n    /**\r\n     * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n     * [0, 100] and then make a function that maps that to the actual keyframes.\r\n     *\r\n     * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n     */\n    let mapPercentToKeyframes;\n    let mirroredGenerator;\n    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n      if (process.env.NODE_ENV !== \"production\") {\n        invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n      }\n      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n      keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({\n      ...this.options,\n      keyframes: keyframes$1\n    });\n    /**\r\n     * If we have a mirror repeat type we need to create a second generator that outputs the\r\n     * mirrored (not reversed) animation and later ping pong between the two generators.\r\n     */\n    if (repeatType === \"mirror\") {\n      mirroredGenerator = generatorFactory({\n        ...this.options,\n        keyframes: [...keyframes$1].reverse(),\n        velocity: -velocity\n      });\n    }\n    /**\r\n     * If duration is undefined and we have repeat options,\r\n     * we need to calculate a duration from the generator.\r\n     *\r\n     * We set it to the generator itself to cache the duration.\r\n     * Any timeline resolver will need to have already precalculated\r\n     * the duration by this step.\r\n     */\n    if (generator.calculatedDuration === null) {\n      generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const {\n      calculatedDuration\n    } = generator;\n    const resolvedDuration = calculatedDuration + repeatDelay;\n    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    return {\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      calculatedDuration,\n      resolvedDuration,\n      totalDuration\n    };\n  }\n  onPostResolved() {\n    const {\n      autoplay = true\n    } = this.options;\n    this.play();\n    if (this.pendingPlayState === \"paused\" || !autoplay) {\n      this.pause();\n    } else {\n      this.state = this.pendingPlayState;\n    }\n  }\n  tick(timestamp, sample = false) {\n    const {\n      resolved\n    } = this;\n    // If the animations has failed to resolve, return the final keyframe.\n    if (!resolved) {\n      const {\n        keyframes\n      } = this.options;\n      return {\n        done: true,\n        value: keyframes[keyframes.length - 1]\n      };\n    }\n    const {\n      finalKeyframe,\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      keyframes,\n      calculatedDuration,\n      totalDuration,\n      resolvedDuration\n    } = resolved;\n    if (this.startTime === null) return generator.next(0);\n    const {\n      delay,\n      repeat,\n      repeatType,\n      repeatDelay,\n      onUpdate\n    } = this.options;\n    /**\r\n     * requestAnimationFrame timestamps can come through as lower than\r\n     * the startTime as set by performance.now(). Here we prevent this,\r\n     * though in the future it could be possible to make setting startTime\r\n     * a pending operation that gets resolved here.\r\n     */\n    if (this.speed > 0) {\n      this.startTime = Math.min(this.startTime, timestamp);\n    } else if (this.speed < 0) {\n      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n    }\n    // Update currentTime\n    if (sample) {\n      this.currentTime = timestamp;\n    } else if (this.holdTime !== null) {\n      this.currentTime = this.holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n    }\n    // Rebase on delay\n    const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    this.currentTime = Math.max(timeWithoutDelay, 0);\n    // If this animation has finished, set the current time  to the total duration.\n    if (this.state === \"finished\" && this.holdTime === null) {\n      this.currentTime = totalDuration;\n    }\n    let elapsed = this.currentTime;\n    let frameGenerator = generator;\n    if (repeat) {\n      /**\r\n       * Get the current progress (0-1) of the animation. If t is >\r\n       * than duration we'll get values like 2.5 (midway through the\r\n       * third iteration)\r\n       */\n      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n      /**\r\n       * Get the current iteration (0 indexed). For instance the floor of\r\n       * 2.5 is 2.\r\n       */\n      let currentIteration = Math.floor(progress);\n      /**\r\n       * Get the current progress of the iteration by taking the remainder\r\n       * so 2.5 is 0.5 through iteration 2\r\n       */\n      let iterationProgress = progress % 1.0;\n      /**\r\n       * If iteration progress is 1 we count that as the end\r\n       * of the previous iteration.\r\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\r\n       * Reverse progress if we're not running in \"normal\" direction\r\n       */\n      const isOddIteration = Boolean(currentIteration % 2);\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    /**\r\n     * If we're in negative time, set state as the initial keyframe.\r\n     * This prevents delay: x, duration: 0 animations from finishing\r\n     * instantly.\r\n     */\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes[0]\n    } : frameGenerator.next(elapsed);\n    if (mapPercentToKeyframes) {\n      state.value = mapPercentToKeyframes(state.value);\n    }\n    let {\n      done\n    } = state;\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n    }\n    const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n    if (isAnimationFinished && finalKeyframe !== undefined) {\n      state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n    }\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      this.finish();\n    }\n    return state;\n  }\n  get duration() {\n    const {\n      resolved\n    } = this;\n    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n  }\n  get time() {\n    return millisecondsToSeconds(this.currentTime);\n  }\n  set time(newTime) {\n    newTime = secondsToMilliseconds(newTime);\n    this.currentTime = newTime;\n    if (this.holdTime !== null || this.speed === 0) {\n      this.holdTime = newTime;\n    } else if (this.driver) {\n      this.startTime = this.driver.now() - newTime / this.speed;\n    }\n  }\n  get speed() {\n    return this.playbackSpeed;\n  }\n  set speed(newSpeed) {\n    const hasChanged = this.playbackSpeed !== newSpeed;\n    this.playbackSpeed = newSpeed;\n    if (hasChanged) {\n      this.time = millisecondsToSeconds(this.currentTime);\n    }\n  }\n  play() {\n    if (!this.resolver.isScheduled) {\n      this.resolver.resume();\n    }\n    if (!this._resolved) {\n      this.pendingPlayState = \"running\";\n      return;\n    }\n    if (this.isStopped) return;\n    const {\n      driver = frameloopDriver,\n      onPlay,\n      startTime\n    } = this.options;\n    if (!this.driver) {\n      this.driver = driver(timestamp => this.tick(timestamp));\n    }\n    onPlay && onPlay();\n    const now = this.driver.now();\n    if (this.holdTime !== null) {\n      this.startTime = now - this.holdTime;\n    } else if (!this.startTime) {\n      this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n    } else if (this.state === \"finished\") {\n      this.startTime = now;\n    }\n    if (this.state === \"finished\") {\n      this.updateFinishedPromise();\n    }\n    this.cancelTime = this.startTime;\n    this.holdTime = null;\n    /**\r\n     * Set playState to running only after we've used it in\r\n     * the previous logic.\r\n     */\n    this.state = \"running\";\n    this.driver.start();\n  }\n  pause() {\n    var _a;\n    if (!this._resolved) {\n      this.pendingPlayState = \"paused\";\n      return;\n    }\n    this.state = \"paused\";\n    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n  }\n  complete() {\n    if (this.state !== \"running\") {\n      this.play();\n    }\n    this.pendingPlayState = this.state = \"finished\";\n    this.holdTime = null;\n  }\n  finish() {\n    this.teardown();\n    this.state = \"finished\";\n    const {\n      onComplete\n    } = this.options;\n    onComplete && onComplete();\n  }\n  cancel() {\n    if (this.cancelTime !== null) {\n      this.tick(this.cancelTime);\n    }\n    this.teardown();\n    this.updateFinishedPromise();\n  }\n  teardown() {\n    this.state = \"idle\";\n    this.stopDriver();\n    this.resolveFinishedPromise();\n    this.updateFinishedPromise();\n    this.startTime = this.cancelTime = null;\n    this.resolver.cancel();\n  }\n  stopDriver() {\n    if (!this.driver) return;\n    this.driver.stop();\n    this.driver = undefined;\n  }\n  sample(time) {\n    this.startTime = 0;\n    return this.tick(time, true);\n  }\n}\n// Legacy interface\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\nexport { MainThreadAnimation, animateValue };","map":{"version":3,"names":["KeyframeResolver","spring","inertia","keyframes","BaseAnimation","pipe","mix","calcGeneratorDuration","millisecondsToSeconds","secondsToMilliseconds","clamp","invariant","frameloopDriver","getFinalKeyframe","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","constructor","options","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","state","stop","resolver","cancel","isStopped","teardown","onStop","name","motionValue","element","KeyframeResolver$1","onResolved","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","initPlayback","keyframes$1","type","repeat","repeatDelay","repeatType","velocity","generatorFactory","mapPercentToKeyframes","mirroredGenerator","process","env","NODE_ENV","length","generator","reverse","calculatedDuration","resolvedDuration","totalDuration","onPostResolved","autoplay","play","pause","tick","timestamp","sample","resolved","done","value","next","delay","onUpdate","speed","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","isAnimationFinished","undefined","finish","duration","time","newTime","driver","now","newSpeed","hasChanged","isScheduled","resume","_resolved","onPlay","calcStartTime","updateFinishedPromise","start","_a","complete","onComplete","stopDriver","resolveFinishedPromise","animateValue"],"sources":["C:/Alexander/Software Developement/repos/Web2/Fitness-Tracker/front-end/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"],"sourcesContent":["import { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { spring } from '../generators/spring/index.mjs';\r\nimport { inertia } from '../generators/inertia.mjs';\r\nimport { keyframes } from '../generators/keyframes.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { mix } from '../../utils/mix/index.mjs';\r\nimport { calcGeneratorDuration } from '../generators/utils/calc-duration.mjs';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { invariant } from '../../utils/errors.mjs';\r\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\nconst generators = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\nconst percentToProgress = (percent) => percent / 100;\r\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\r\nclass MainThreadAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        /**\r\n         * The time at which the animation was paused.\r\n         */\r\n        this.holdTime = null;\r\n        /**\r\n         * The time at which the animation was cancelled.\r\n         */\r\n        this.cancelTime = null;\r\n        /**\r\n         * The current time of the animation.\r\n         */\r\n        this.currentTime = 0;\r\n        /**\r\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n         */\r\n        this.playbackSpeed = 1;\r\n        /**\r\n         * The state of the animation to apply when the animation is resolved. This\r\n         * allows calls to the public API to control the animation before it is resolved,\r\n         * without us having to resolve it first.\r\n         */\r\n        this.pendingPlayState = \"running\";\r\n        /**\r\n         * The time at which the animation was started.\r\n         */\r\n        this.startTime = null;\r\n        this.state = \"idle\";\r\n        /**\r\n         * This method is bound to the instance to fix a pattern where\r\n         * animation.stop is returned as a reference from a useEffect.\r\n         */\r\n        this.stop = () => {\r\n            this.resolver.cancel();\r\n            this.isStopped = true;\r\n            if (this.state === \"idle\")\r\n                return;\r\n            this.teardown();\r\n            const { onStop } = this.options;\r\n            onStop && onStop();\r\n        };\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\r\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\r\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    initPlayback(keyframes$1) {\r\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\r\n        const generatorFactory = generators[type] || keyframes;\r\n        /**\r\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n         * [0, 100] and then make a function that maps that to the actual keyframes.\r\n         *\r\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n         */\r\n        let mapPercentToKeyframes;\r\n        let mirroredGenerator;\r\n        if (generatorFactory !== keyframes &&\r\n            typeof keyframes$1[0] !== \"number\") {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n            }\r\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\r\n            keyframes$1 = [0, 100];\r\n        }\r\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\r\n        /**\r\n         * If we have a mirror repeat type we need to create a second generator that outputs the\r\n         * mirrored (not reversed) animation and later ping pong between the two generators.\r\n         */\r\n        if (repeatType === \"mirror\") {\r\n            mirroredGenerator = generatorFactory({\r\n                ...this.options,\r\n                keyframes: [...keyframes$1].reverse(),\r\n                velocity: -velocity,\r\n            });\r\n        }\r\n        /**\r\n         * If duration is undefined and we have repeat options,\r\n         * we need to calculate a duration from the generator.\r\n         *\r\n         * We set it to the generator itself to cache the duration.\r\n         * Any timeline resolver will need to have already precalculated\r\n         * the duration by this step.\r\n         */\r\n        if (generator.calculatedDuration === null) {\r\n            generator.calculatedDuration = calcGeneratorDuration(generator);\r\n        }\r\n        const { calculatedDuration } = generator;\r\n        const resolvedDuration = calculatedDuration + repeatDelay;\r\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n        return {\r\n            generator,\r\n            mirroredGenerator,\r\n            mapPercentToKeyframes,\r\n            calculatedDuration,\r\n            resolvedDuration,\r\n            totalDuration,\r\n        };\r\n    }\r\n    onPostResolved() {\r\n        const { autoplay = true } = this.options;\r\n        this.play();\r\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\r\n            this.pause();\r\n        }\r\n        else {\r\n            this.state = this.pendingPlayState;\r\n        }\r\n    }\r\n    tick(timestamp, sample = false) {\r\n        const { resolved } = this;\r\n        // If the animations has failed to resolve, return the final keyframe.\r\n        if (!resolved) {\r\n            const { keyframes } = this.options;\r\n            return { done: true, value: keyframes[keyframes.length - 1] };\r\n        }\r\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\r\n        if (this.startTime === null)\r\n            return generator.next(0);\r\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (this.speed > 0) {\r\n            this.startTime = Math.min(this.startTime, timestamp);\r\n        }\r\n        else if (this.speed < 0) {\r\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\r\n        }\r\n        // Update currentTime\r\n        if (sample) {\r\n            this.currentTime = timestamp;\r\n        }\r\n        else if (this.holdTime !== null) {\r\n            this.currentTime = this.holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            this.currentTime =\r\n                Math.round(timestamp - this.startTime) * this.speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = this.speed >= 0\r\n            ? timeWithoutDelay < 0\r\n            : timeWithoutDelay > totalDuration;\r\n        this.currentTime = Math.max(timeWithoutDelay, 0);\r\n        // If this animation has finished, set the current time  to the total duration.\r\n        if (this.state === \"finished\" && this.holdTime === null) {\r\n            this.currentTime = totalDuration;\r\n        }\r\n        let elapsed = this.currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapPercentToKeyframes) {\r\n            state.value = mapPercentToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done =\r\n                this.speed >= 0\r\n                    ? this.currentTime >= totalDuration\r\n                    : this.currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = this.holdTime === null &&\r\n            (this.state === \"finished\" || (this.state === \"running\" && done));\r\n        if (isAnimationFinished && finalKeyframe !== undefined) {\r\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\r\n        }\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            this.finish();\r\n        }\r\n        return state;\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(this.currentTime);\r\n    }\r\n    set time(newTime) {\r\n        newTime = secondsToMilliseconds(newTime);\r\n        this.currentTime = newTime;\r\n        if (this.holdTime !== null || this.speed === 0) {\r\n            this.holdTime = newTime;\r\n        }\r\n        else if (this.driver) {\r\n            this.startTime = this.driver.now() - newTime / this.speed;\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.playbackSpeed;\r\n    }\r\n    set speed(newSpeed) {\r\n        const hasChanged = this.playbackSpeed !== newSpeed;\r\n        this.playbackSpeed = newSpeed;\r\n        if (hasChanged) {\r\n            this.time = millisecondsToSeconds(this.currentTime);\r\n        }\r\n    }\r\n    play() {\r\n        if (!this.resolver.isScheduled) {\r\n            this.resolver.resume();\r\n        }\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"running\";\r\n            return;\r\n        }\r\n        if (this.isStopped)\r\n            return;\r\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\r\n        if (!this.driver) {\r\n            this.driver = driver((timestamp) => this.tick(timestamp));\r\n        }\r\n        onPlay && onPlay();\r\n        const now = this.driver.now();\r\n        if (this.holdTime !== null) {\r\n            this.startTime = now - this.holdTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        }\r\n        else if (this.state === \"finished\") {\r\n            this.startTime = now;\r\n        }\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        this.cancelTime = this.startTime;\r\n        this.holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        this.state = \"running\";\r\n        this.driver.start();\r\n    }\r\n    pause() {\r\n        var _a;\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"paused\";\r\n            return;\r\n        }\r\n        this.state = \"paused\";\r\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    complete() {\r\n        if (this.state !== \"running\") {\r\n            this.play();\r\n        }\r\n        this.pendingPlayState = this.state = \"finished\";\r\n        this.holdTime = null;\r\n    }\r\n    finish() {\r\n        this.teardown();\r\n        this.state = \"finished\";\r\n        const { onComplete } = this.options;\r\n        onComplete && onComplete();\r\n    }\r\n    cancel() {\r\n        if (this.cancelTime !== null) {\r\n            this.tick(this.cancelTime);\r\n        }\r\n        this.teardown();\r\n        this.updateFinishedPromise();\r\n    }\r\n    teardown() {\r\n        this.state = \"idle\";\r\n        this.stopDriver();\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        this.startTime = this.cancelTime = null;\r\n        this.resolver.cancel();\r\n    }\r\n    stopDriver() {\r\n        if (!this.driver)\r\n            return;\r\n        this.driver.stop();\r\n        this.driver = undefined;\r\n    }\r\n    sample(time) {\r\n        this.startTime = 0;\r\n        return this.tick(time, true);\r\n    }\r\n}\r\n// Legacy interface\r\nfunction animateValue(options) {\r\n    return new MainThreadAnimation(options);\r\n}\r\n\r\nexport { MainThreadAnimation, animateValue };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}