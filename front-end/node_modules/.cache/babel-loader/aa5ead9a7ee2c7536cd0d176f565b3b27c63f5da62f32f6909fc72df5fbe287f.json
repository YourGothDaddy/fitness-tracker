{"ast":null,"code":"import { Ray, Matrix4, Mesh, Vector3 } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\nconst ray = /* @__PURE__ */new Ray();\nconst direction = /* @__PURE__ */new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst _worldScale = /* @__PURE__ */new Vector3();\nexport function acceleratedRaycast(raycaster, intersects) {\n  if (this.geometry.boundsTree) {\n    if (this.material === undefined) return;\n    tmpInverseMatrix.copy(this.matrixWorld).invert();\n    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n    extractMatrixScale(this.matrixWorld, _worldScale);\n    direction.copy(ray.direction).multiply(_worldScale);\n    const scaleFactor = direction.length();\n    const near = raycaster.near / scaleFactor;\n    const far = raycaster.far / scaleFactor;\n    const bvh = this.geometry.boundsTree;\n    if (raycaster.firstHitOnly === true) {\n      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material, near, far), this, raycaster);\n      if (hit) {\n        intersects.push(hit);\n      }\n    } else {\n      const hits = bvh.raycast(ray, this.material, near, far);\n      for (let i = 0, l = hits.length; i < l; i++) {\n        const hit = convertRaycastIntersect(hits[i], this, raycaster);\n        if (hit) {\n          intersects.push(hit);\n        }\n      }\n    }\n  } else {\n    origMeshRaycastFunc.call(this, raycaster, intersects);\n  }\n}\nexport function computeBoundsTree(options) {\n  this.boundsTree = new MeshBVH(this, options);\n  return this.boundsTree;\n}\nexport function disposeBoundsTree() {\n  this.boundsTree = null;\n}\n\n// https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js#L732\n// extracting the scale directly is ~3x faster than using \"decompose\"\nfunction extractMatrixScale(matrix, target) {\n  const te = matrix.elements;\n  const sx = target.set(te[0], te[1], te[2]).length();\n  const sy = target.set(te[4], te[5], te[6]).length();\n  const sz = target.set(te[8], te[9], te[10]).length();\n  return target.set(sx, sy, sz);\n}","map":{"version":3,"names":["Ray","Matrix4","Mesh","Vector3","convertRaycastIntersect","MeshBVH","ray","direction","tmpInverseMatrix","origMeshRaycastFunc","prototype","raycast","_worldScale","acceleratedRaycast","raycaster","intersects","geometry","boundsTree","material","undefined","copy","matrixWorld","invert","applyMatrix4","extractMatrixScale","multiply","scaleFactor","length","near","far","bvh","firstHitOnly","hit","raycastFirst","push","hits","i","l","call","computeBoundsTree","options","disposeBoundsTree","matrix","target","te","elements","sx","set","sy","sz"],"sources":["C:/Alexander/Software Developement/repos/Web2/Fitness-Tracker/front-end/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js"],"sourcesContent":["import { Ray, Matrix4, Mesh, Vector3 } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst ray = /* @__PURE__ */ new Ray();\nconst direction = /* @__PURE__ */ new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst _worldScale = /* @__PURE__ */ new Vector3();\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\textractMatrixScale( this.matrixWorld, _worldScale );\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js#L732\n// extracting the scale directly is ~3x faster than using \"decompose\"\nfunction extractMatrixScale( matrix, target ) {\n\n\tconst te = matrix.elements;\n\tconst sx = target.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\tconst sy = target.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\tconst sz = target.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\treturn target.set( sx, sy, sz );\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}