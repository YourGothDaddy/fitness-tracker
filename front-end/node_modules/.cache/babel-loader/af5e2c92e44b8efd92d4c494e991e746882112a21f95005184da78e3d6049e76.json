{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\nfunction scalePoint(point, scale, originPoint) {\n  const distanceFromOrigin = point - originPoint;\n  const scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\r\n * Applies a translate/scale delta to a point\r\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Applies a translate/scale delta to a box\r\n */\nfunction applyBoxDelta(box, {\n  x,\n  y\n}) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  const treeLength = treePath.length;\n  if (!treeLength) return;\n  // Reset the treeScale\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\r\n     * TODO: Prefer to remove this, but currently we have motion components with\r\n     * display: contents in Framer.\r\n     */\n    const {\n      visualElement\n    } = node.options;\n    if (visualElement && visualElement.props.style && visualElement.props.style.display === \"contents\") {\n      continue;\n    }\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      // Apply each ancestor's calculated delta into this component's recorded layout box\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\r\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n   * This will help reduce useless scales getting rendered.\r\n   */\n  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {\n    treeScale.x = 1.0;\n  }\n  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {\n    treeScale.y = 1.0;\n  }\n}\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n  // Apply the axis delta to the final axis\n  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"names":["mixNumber","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY"],"sources":["C:/Alexander/Software Developement/repos/Web2/Fitness-Tracker/front-end/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    const distanceFromOrigin = point - originPoint;\r\n    const scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, { x, y }) {\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\r\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\r\n    const treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    let node;\r\n    let delta;\r\n    for (let i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        /**\r\n         * TODO: Prefer to remove this, but currently we have motion components with\r\n         * display: contents in Framer.\r\n         */\r\n        const { visualElement } = node.options;\r\n        if (visualElement &&\r\n            visualElement.props.style &&\r\n            visualElement.props.style.display === \"contents\") {\r\n            continue;\r\n        }\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, {\r\n                x: -node.scroll.offset.x,\r\n                y: -node.scroll.offset.y,\r\n            });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n    /**\r\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n     * This will help reduce useless scales getting rendered.\r\n     */\r\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.x = 1.0;\r\n    }\r\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.y = 1.0;\r\n    }\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\r\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\r\n}\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\r\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}