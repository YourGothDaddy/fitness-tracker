{"ast":null,"code":"import { appearStoreId } from './store-id.mjs';\nimport { animateStyle } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, elementsWithAppearAnimations } from './store.mjs';\nimport { noop } from '../../utils/noop.mjs';\n\n/**\r\n * A single time to use across all animations to manually set startTime\r\n * and ensure they're all in sync.\r\n */\nlet startFrameTime;\n/**\r\n * A dummy animation to detect when Chrome is ready to start\r\n * painting the page and hold off from triggering the real animation\r\n * until then. We only need one animation to detect paint ready.\r\n *\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\r\n */\nlet readyAnimation;\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionHandoffIsComplete) {\n    window.MotionHandoffAnimation = undefined;\n    return;\n  }\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n  if (!readyAnimation) {\n    readyAnimation = animateStyle(element, name, [keyframes[0], keyframes[0]],\n    /**\r\n     * 10 secs is basically just a super-safe duration to give Chrome\r\n     * long enough to get the animation ready.\r\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\r\n     * If there's no readyAnimation then there's been no instantiation\r\n     * of handoff animations.\r\n     */\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    window.MotionHasOptimisedTransformAnimation = elementId => {\n      if (!elementId) return false;\n      const animationId = appearStoreId(elementId, \"transform\");\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n    /**\r\n     * We only need to cancel transform animations as\r\n     * they're the ones that will interfere with the\r\n     * layout animation measurements.\r\n     */\n    window.MotionCancelOptimisedTransform = elementId => {\n      const animationId = appearStoreId(elementId, \"transform\");\n      const data = appearAnimationStore.get(animationId);\n      if (data) {\n        data.animation.cancel();\n        appearAnimationStore.delete(animationId);\n      }\n    };\n    /**\r\n     * Keep a map of elementIds that have started animating. We check\r\n     * via ID instead of Element because of hydration errors and\r\n     * pre-hydration checks. We also actively record IDs as they start\r\n     * animating rather than simply checking for data-appear-id as\r\n     * this attrbute might be present but not lead to an animation, for\r\n     * instance if the element's appear animation is on a different\r\n     * breakpoint.\r\n     */\n    window.MotionHasOptimisedAnimation = elementId => Boolean(elementId && elementsWithAppearAnimations.has(elementId));\n  }\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = animateStyle(element, name, keyframes, options);\n    /**\r\n     * Record the time of the first started animation. We call performance.now() once\r\n     * here and once in handoff to ensure we're getting\r\n     * close to a frame-locked time. This keeps all animations in sync.\r\n     */\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n  elementsWithAppearAnimations.add(id);\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\nexport { startOptimizedAppearAnimation };","map":{"version":3,"names":["appearStoreId","animateStyle","optimizedAppearDataId","handoffOptimizedAppearAnimation","appearAnimationStore","elementsWithAppearAnimations","noop","startFrameTime","readyAnimation","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionHandoffIsComplete","MotionHandoffAnimation","undefined","id","dataset","storeId","duration","ease","set","animation","startTime","MotionHasOptimisedTransformAnimation","elementId","animationId","Boolean","get","MotionCancelOptimisedTransform","data","cancel","delete","MotionHasOptimisedAnimation","has","startAnimation","appearAnimation","performance","now","add","ready","then","catch"],"sources":["C:/Alexander/Software Developement/repos/Web2/Fitness-Tracker/front-end/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"sourcesContent":["import { appearStoreId } from './store-id.mjs';\r\nimport { animateStyle } from '../animators/waapi/index.mjs';\r\nimport { optimizedAppearDataId } from './data-id.mjs';\r\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\r\nimport { appearAnimationStore, elementsWithAppearAnimations } from './store.mjs';\r\nimport { noop } from '../../utils/noop.mjs';\r\n\r\n/**\r\n * A single time to use across all animations to manually set startTime\r\n * and ensure they're all in sync.\r\n */\r\nlet startFrameTime;\r\n/**\r\n * A dummy animation to detect when Chrome is ready to start\r\n * painting the page and hold off from triggering the real animation\r\n * until then. We only need one animation to detect paint ready.\r\n *\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\r\n */\r\nlet readyAnimation;\r\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\r\n    // Prevent optimised appear animations if Motion has already started animating.\r\n    if (window.MotionHandoffIsComplete) {\r\n        window.MotionHandoffAnimation = undefined;\r\n        return;\r\n    }\r\n    const id = element.dataset[optimizedAppearDataId];\r\n    if (!id)\r\n        return;\r\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\r\n    const storeId = appearStoreId(id, name);\r\n    if (!readyAnimation) {\r\n        readyAnimation = animateStyle(element, name, [keyframes[0], keyframes[0]], \r\n        /**\r\n         * 10 secs is basically just a super-safe duration to give Chrome\r\n         * long enough to get the animation ready.\r\n         */\r\n        { duration: 10000, ease: \"linear\" });\r\n        appearAnimationStore.set(storeId, {\r\n            animation: readyAnimation,\r\n            startTime: null,\r\n        });\r\n        /**\r\n         * If there's no readyAnimation then there's been no instantiation\r\n         * of handoff animations.\r\n         */\r\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\r\n        window.MotionHasOptimisedTransformAnimation = (elementId) => {\r\n            if (!elementId)\r\n                return false;\r\n            const animationId = appearStoreId(elementId, \"transform\");\r\n            return Boolean(appearAnimationStore.get(animationId));\r\n        };\r\n        /**\r\n         * We only need to cancel transform animations as\r\n         * they're the ones that will interfere with the\r\n         * layout animation measurements.\r\n         */\r\n        window.MotionCancelOptimisedTransform = (elementId) => {\r\n            const animationId = appearStoreId(elementId, \"transform\");\r\n            const data = appearAnimationStore.get(animationId);\r\n            if (data) {\r\n                data.animation.cancel();\r\n                appearAnimationStore.delete(animationId);\r\n            }\r\n        };\r\n        /**\r\n         * Keep a map of elementIds that have started animating. We check\r\n         * via ID instead of Element because of hydration errors and\r\n         * pre-hydration checks. We also actively record IDs as they start\r\n         * animating rather than simply checking for data-appear-id as\r\n         * this attrbute might be present but not lead to an animation, for\r\n         * instance if the element's appear animation is on a different\r\n         * breakpoint.\r\n         */\r\n        window.MotionHasOptimisedAnimation = (elementId) => Boolean(elementId && elementsWithAppearAnimations.has(elementId));\r\n    }\r\n    const startAnimation = () => {\r\n        readyAnimation.cancel();\r\n        const appearAnimation = animateStyle(element, name, keyframes, options);\r\n        /**\r\n         * Record the time of the first started animation. We call performance.now() once\r\n         * here and once in handoff to ensure we're getting\r\n         * close to a frame-locked time. This keeps all animations in sync.\r\n         */\r\n        if (startFrameTime === undefined) {\r\n            startFrameTime = performance.now();\r\n        }\r\n        appearAnimation.startTime = startFrameTime;\r\n        appearAnimationStore.set(storeId, {\r\n            animation: appearAnimation,\r\n            startTime: startFrameTime,\r\n        });\r\n        if (onReady)\r\n            onReady(appearAnimation);\r\n    };\r\n    elementsWithAppearAnimations.add(id);\r\n    if (readyAnimation.ready) {\r\n        readyAnimation.ready.then(startAnimation).catch(noop);\r\n    }\r\n    else {\r\n        startAnimation();\r\n    }\r\n}\r\n\r\nexport { startOptimizedAppearAnimation };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}