{"ast":null,"code":"function createRenderStep(runNextFrame) {\n  /**\r\n   * We create and reuse two queues, one to queue jobs for the current frame\r\n   * and one for the next. We reuse to avoid triggering GC after x frames.\r\n   */\n  let thisFrame = new Set();\n  let nextFrame = new Set();\n  /**\r\n   * Track whether we're currently processing jobs in this step. This way\r\n   * we can decide whether to schedule new jobs for this frame or next.\r\n   */\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\r\n   * A set of processes which were marked keepAlive when scheduled.\r\n   */\n  const toKeepAlive = new WeakSet();\n  let latestFrameData = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n  function triggerCallback(callback) {\n    if (toKeepAlive.has(callback)) {\n      step.schedule(callback);\n      runNextFrame();\n    }\n    callback(latestFrameData);\n  }\n  const step = {\n    /**\r\n     * Schedule a process to run on the next frame.\r\n     */\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (!queue.has(callback)) queue.add(callback);\n      return callback;\n    },\n    /**\r\n     * Cancel the provided callback from running on the next frame.\r\n     */\n    cancel: callback => {\n      nextFrame.delete(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\r\n     * Execute all schedule callbacks.\r\n     */\n    process: frameData => {\n      latestFrameData = frameData;\n      /**\r\n       * If we're already processing we've probably been triggered by a flushSync\r\n       * inside an existing process. Instead of executing, mark flushNextFrame\r\n       * as true and ensure we flush the following frame at the end of this one.\r\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame];\n      // Clear the next frame queue\n      nextFrame.clear();\n      // Execute this frame\n      thisFrame.forEach(triggerCallback);\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nexport { createRenderStep };","map":{"version":3,"names":["createRenderStep","runNextFrame","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","triggerCallback","callback","has","step","schedule","keepAlive","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","clear","forEach"],"sources":["C:/Alexander/Software Developement/repos/Web2/Fitness-Tracker/front-end/node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["function createRenderStep(runNextFrame) {\r\n    /**\r\n     * We create and reuse two queues, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let thisFrame = new Set();\r\n    let nextFrame = new Set();\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    let latestFrameData = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    function triggerCallback(callback) {\r\n        if (toKeepAlive.has(callback)) {\r\n            step.schedule(callback);\r\n            runNextFrame();\r\n        }\r\n        callback(latestFrameData);\r\n    }\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            if (!queue.has(callback))\r\n                queue.add(callback);\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            nextFrame.delete(callback);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            latestFrameData = frameData;\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\r\n            // Clear the next frame queue\r\n            nextFrame.clear();\r\n            // Execute this frame\r\n            thisFrame.forEach(triggerCallback);\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n"],"mappings":"AAAA,SAASA,gBAAgBA,CAACC,YAAY,EAAE;EACpC;AACJ;AACA;AACA;EACI,IAAIC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIC,SAAS,GAAG,IAAID,GAAG,CAAC,CAAC;EACzB;AACJ;AACA;AACA;EACI,IAAIE,YAAY,GAAG,KAAK;EACxB,IAAIC,cAAc,GAAG,KAAK;EAC1B;AACJ;AACA;EACI,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAAC;EACjC,IAAIC,eAAe,GAAG;IAClBC,KAAK,EAAE,GAAG;IACVC,SAAS,EAAE,GAAG;IACdN,YAAY,EAAE;EAClB,CAAC;EACD,SAASO,eAAeA,CAACC,QAAQ,EAAE;IAC/B,IAAIN,WAAW,CAACO,GAAG,CAACD,QAAQ,CAAC,EAAE;MAC3BE,IAAI,CAACC,QAAQ,CAACH,QAAQ,CAAC;MACvBZ,YAAY,CAAC,CAAC;IAClB;IACAY,QAAQ,CAACJ,eAAe,CAAC;EAC7B;EACA,MAAMM,IAAI,GAAG;IACT;AACR;AACA;IACQC,QAAQ,EAAEA,CAACH,QAAQ,EAAEI,SAAS,GAAG,KAAK,EAAEC,SAAS,GAAG,KAAK,KAAK;MAC1D,MAAMC,iBAAiB,GAAGD,SAAS,IAAIb,YAAY;MACnD,MAAMe,KAAK,GAAGD,iBAAiB,GAAGjB,SAAS,GAAGE,SAAS;MACvD,IAAIa,SAAS,EACTV,WAAW,CAACc,GAAG,CAACR,QAAQ,CAAC;MAC7B,IAAI,CAACO,KAAK,CAACN,GAAG,CAACD,QAAQ,CAAC,EACpBO,KAAK,CAACC,GAAG,CAACR,QAAQ,CAAC;MACvB,OAAOA,QAAQ;IACnB,CAAC;IACD;AACR;AACA;IACQS,MAAM,EAAGT,QAAQ,IAAK;MAClBT,SAAS,CAACmB,MAAM,CAACV,QAAQ,CAAC;MAC1BN,WAAW,CAACgB,MAAM,CAACV,QAAQ,CAAC;IAChC,CAAC;IACD;AACR;AACA;IACQW,OAAO,EAAGC,SAAS,IAAK;MACpBhB,eAAe,GAAGgB,SAAS;MAC3B;AACZ;AACA;AACA;AACA;MACY,IAAIpB,YAAY,EAAE;QACdC,cAAc,GAAG,IAAI;QACrB;MACJ;MACAD,YAAY,GAAG,IAAI;MACnB,CAACH,SAAS,EAAEE,SAAS,CAAC,GAAG,CAACA,SAAS,EAAEF,SAAS,CAAC;MAC/C;MACAE,SAAS,CAACsB,KAAK,CAAC,CAAC;MACjB;MACAxB,SAAS,CAACyB,OAAO,CAACf,eAAe,CAAC;MAClCP,YAAY,GAAG,KAAK;MACpB,IAAIC,cAAc,EAAE;QAChBA,cAAc,GAAG,KAAK;QACtBS,IAAI,CAACS,OAAO,CAACC,SAAS,CAAC;MAC3B;IACJ;EACJ,CAAC;EACD,OAAOV,IAAI;AACf;AAEA,SAASf,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}